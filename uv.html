<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Klar-himmel UV (GPS) 07–19</title>
  <style>
    :root{
      --bg:#0b0f14; --text:#e7eef7; --muted:#a9b7c6;
      --border:rgba(255,255,255,.09); --accent:#56b6c2; --danger:#e06c75;
      --panelA:rgba(255,255,255,.04); --panelB:rgba(255,255,255,.02);

      /* UV band colors (subtle; tuned for dark UI) */
      --uv-low:   rgba(152,195,121,0.10); /* 0-2 */
      --uv-mod:   rgba(229,192,123,0.10); /* 3-5 */
      --uv-high:  rgba(224,108,117,0.10); /* 6-7 */
      --uv-vhigh: rgba(198,120,221,0.12); /* 8-10 */
      --uv-ext:   rgba(97,175,239,0.12);  /* 11+ */
    }
    *{box-sizing:border-box}
    body{
      margin:0; padding:18px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 20% 0%, rgba(86,182,194,.18), transparent 60%), var(--bg);
      color:var(--text);
    }
    .wrap{max-width:980px;margin:0 auto;display:grid;gap:14px}
    header{display:flex;flex-wrap:wrap;gap:10px 14px;align-items:baseline}
    h1{font-size:18px;margin:0}
    .tag{font-size:12px;color:var(--muted);border:1px solid var(--border);padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.03)}
    .panel{
      background:linear-gradient(180deg, var(--panelA), var(--panelB));
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px
    }
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;align-items:end}
    @media (max-width:700px){.row{grid-template-columns:1fr}}
    label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    input[type="date"], input[type="number"]{
      width:100%; padding:10px;
      border-radius:10px;border:1px solid var(--border);
      background:rgba(0,0,0,.25);color:var(--text);outline:none
    }
    input[type="range"]{width:100%}
    .btns{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
    button{
      cursor:pointer; border:1px solid var(--border);
      background:rgba(255,255,255,.04); color:var(--text);
      padding:10px 12px; border-radius:10px; font-weight:600;
    }
    button.primary{border-color:rgba(86,182,194,.55);background:rgba(86,182,194,.12)}
    button:hover{background:rgba(255,255,255,.07)}
    button.primary:hover{background:rgba(86,182,194,.18)}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .small{font-size:12px;color:var(--muted);line-height:1.4}
    .pill{
      display:flex;justify-content:space-between;gap:10px;align-items:center;
      padding:8px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,.03);
      font-size:12px;color:var(--muted)
    }
    canvas{
      width:100%; height:360px;
      background:rgba(0,0,0,.18);
      border:1px solid var(--border);
      border-radius:12px;
    }
    .status{font-size:12px;color:var(--muted)}
    .status.err{color:var(--danger)}

    details{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      background:rgba(0,0,0,.16);
      margin-top:12px;
    }
    summary{
      cursor:pointer;
      color:var(--text);
      font-weight:700;
      list-style:none;
      display:flex;
      align-items:center;
      gap:10px;
    }
    summary::-webkit-details-marker { display:none; }
    .chev{
      width:10px;height:10px;display:inline-block;
      border-right:2px solid rgba(231,238,247,.7);
      border-bottom:2px solid rgba(231,238,247,.7);
      transform:rotate(-45deg);
      margin-top:2px;
    }
    details[open] .chev{ transform:rotate(45deg); margin-top:0; }
    .advGrid{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width:700px){.advGrid{grid-template-columns:1fr}}
    .legend{
      display:flex; flex-wrap:wrap; gap:8px; margin-top:10px
    }
    .lg{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--border); background:rgba(255,255,255,.03);
      padding:6px 10px; border-radius:999px; font-size:12px; color:var(--muted)
    }
    .sw{width:10px;height:10px;border-radius:3px; display:inline-block}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Klar-himmel UV-index (GPS) 07:00–19:00</h1>
      <span class="tag">Endast solgeometri · ingen molnprognos</span>
    </header>

    <section class="panel">
      <div class="row">
        <label>
          Datum (för din plats)
          <input id="dateInput" type="date" />
        </label>

        <div style="display:grid;gap:10px">
          <div class="btns" style="margin:0">
            <button class="primary" id="geoBtn">Hämta GPS-position</button>
            <button id="redrawBtn">Rita om</button>
          </div>
          <div id="status" class="status">Redo. Tryck “Hämta GPS-position”.</div>
        </div>
      </div>

      <details>
        <summary><span class="chev"></span> Avancerade inställningar</summary>

        <div class="advGrid">
          <label>
            Sampling (minuter)
            <input id="stepInput" type="number" min="5" max="60" step="5" value="10" />
            <span class="small">T.ex. 10 min ger en slät kurva utan att bli tungt.</span>
          </label>

          <label>
            K (skalning)
            <input id="kRange" type="range" min="6" max="16" step="0.1" value="11.0" />
            <span class="mono" id="kVal">11.0</span>
          </label>

          <label>
            n (exponent)
            <input id="nRange" type="range" min="1.0" max="1.8" step="0.01" value="1.30" />
            <span class="mono" id="nVal">1.30</span>
          </label>

          <div>
            <div class="small" style="margin-top:2px;">
              <b>Modell</b><br/>
              <span class="mono">UV = K · sin(elev)^n</span><br/>
              där <span class="mono">elev</span> är solens höjdvinkel (grader) vid din lat/lon, datum och lokal klocktid.
              Vi antar klar himmel (inga moln) och använder en enkel solpositions-approximation med “equation of time”.
              <br/><br/>
              <b>Hur man använder</b><br/>
              • <span class="mono">K</span> flyttar upp/ner hela kurvan (kalibrera mot “klar himmel”-känslan).<br/>
              • <span class="mono">n</span> gör toppen spetsigare (högre n) eller bredare (lägre n).<br/>
              • Det här är “maximal möjlig UV om solen tittar fram”, inte ett väderjusterat värde.
            </div>
          </div>
        </div>

        <div class="legend">
          <div class="lg"><span class="sw" style="background:var(--uv-low)"></span>0–2 Låg</div>
          <div class="lg"><span class="sw" style="background:var(--uv-mod)"></span>3–5 Måttlig</div>
          <div class="lg"><span class="sw" style="background:var(--uv-high)"></span>6–7 Hög</div>
          <div class="lg"><span class="sw" style="background:var(--uv-vhigh)"></span>8–10 Mycket hög</div>
          <div class="lg"><span class="sw" style="background:var(--uv-ext)"></span>11+ Extrem</div>
        </div>
      </details>
    </section>

    <section class="panel">
      <div class="pill"><span>Lat / Lon</span><span class="mono" id="latLon">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>UTC-offset (från din telefon)</span><span class="mono" id="tzShow">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>Max UV</span><span class="mono" id="maxUv">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>Tid för max</span><span class="mono" id="maxTime">—</span></div>
    </section>

    <section class="panel">
      <canvas id="chart" width="1200" height="500"></canvas>
    </section>
  </div>

<script>
(() => {
  // ---- UI ----
  const el = (id) => document.getElementById(id);
  const dateInput = el("dateInput");
  const stepInput = el("stepInput");
  const kRange = el("kRange");
  const nRange = el("nRange");
  const kVal = el("kVal");
  const nVal = el("nVal");
  const geoBtn = el("geoBtn");
  const redrawBtn = el("redrawBtn");

  const latLon = el("latLon");
  const tzShow = el("tzShow");
  const maxUv = el("maxUv");
  const maxTime = el("maxTime");
  const status = el("status");

  const canvas = el("chart");
  const ctx = canvas.getContext("2d");

  // ---- Model params ----
  const START_H = 7;
  const END_H = 19;

  let state = {
    lat: null,
    lon: null,
    tz: null // UTC offset in hours from device
  };

  function setStatus(msg, isErr=false){
    status.textContent = msg;
    status.classList.toggle("err", !!isErr);
  }

  function pad2(n){ return String(n).padStart(2, "0"); }
  function fmtTime(hFloat){
    const h = Math.floor(hFloat);
    const m = Math.round((hFloat - h) * 60);
    return `${pad2(h)}:${pad2(m)}`;
  }

  function todayLocalYMD(){
    const d = new Date();
    return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  }

  function parseYMD(s){
    const [y,m,d] = s.split("-").map(Number);
    return {y,m,d};
  }

  function dayOfYear(y,m,d){
    const dt = new Date(Date.UTC(y, m-1, d));
    const start = new Date(Date.UTC(y, 0, 1));
    return Math.floor((dt - start)/86400000) + 1;
  }

  // Solar elevation approximation (fractional year + equation of time)
  function solarElevationDeg(localClockHours, latDeg, lonDeg, tzHours, y, m, d){
    const doy = dayOfYear(y,m,d);

    const gamma = 2 * Math.PI / 365 * (doy - 1 + (localClockHours - 12) / 24);

    const decl =
      0.006918
      - 0.399912 * Math.cos(gamma)
      + 0.070257 * Math.sin(gamma)
      - 0.006758 * Math.cos(2 * gamma)
      + 0.000907 * Math.sin(2 * gamma)
      - 0.002697 * Math.cos(3 * gamma)
      + 0.00148  * Math.sin(3 * gamma);

    const eqtime =
      229.18 * (
        0.000075
        + 0.001868 * Math.cos(gamma)
        - 0.032077 * Math.sin(gamma)
        - 0.014615 * Math.cos(2 * gamma)
        - 0.040849 * Math.sin(2 * gamma)
      );

    const minutes = localClockHours * 60;
    const tst = minutes + eqtime + 4 * lonDeg - 60 * tzHours;
    const haDeg = (tst / 4) - 180;
    const ha = haDeg * Math.PI / 180;

    const lat = latDeg * Math.PI / 180;
    const elevRad = Math.asin(
      Math.sin(lat) * Math.sin(decl) +
      Math.cos(lat) * Math.cos(decl) * Math.cos(ha)
    );

    return elevRad * 180 / Math.PI;
  }

  function uvFromElevation(elevDeg, K, n){
    if (elevDeg <= 0) return 0;
    const s = Math.sin(elevDeg * Math.PI / 180);
    return K * Math.pow(Math.max(0, s), n);
  }

  function computeSeries(){
    if (!Number.isFinite(state.lat) || !Number.isFinite(state.lon) || !Number.isFinite(state.tz)) {
      throw new Error("Ingen GPS-position ännu.");
    }
    const {y,m,d} = parseYMD(dateInput.value);
    const step = Math.max(5, Math.min(60, Number(stepInput.value) || 10));
    const K = Number(kRange.value);
    const n = Number(nRange.value);

    const times = [];
    const values = [];

    for (let t = START_H*60; t <= END_H*60; t += step) {
      const h = t/60;
      const elev = solarElevationDeg(h, state.lat, state.lon, state.tz, y, m, d);
      const uv = uvFromElevation(elev, K, n);
      times.push(h);
      values.push(uv);
    }

    let maxV=-1, idx=0;
    for (let i=0;i<values.length;i++){
      if (values[i] > maxV) { maxV = values[i]; idx = i; }
    }
    return {times, values, maxV, maxT: times[idx], step, yMaxRaw: Math.max(1, ...values)};
  }

  // Draw background UV bands (WHO categories)
  function drawUvBands(pad, pw, ph, yMax){
    // bands: [y0,y1,color]
    const bands = [
      [0, 2,  getComputedStyle(document.documentElement).getPropertyValue("--uv-low").trim()],
      [2, 5,  getComputedStyle(document.documentElement).getPropertyValue("--uv-mod").trim()],
      [5, 7,  getComputedStyle(document.documentElement).getPropertyValue("--uv-high").trim()],
      [7, 10, getComputedStyle(document.documentElement).getPropertyValue("--uv-vhigh").trim()],
      [10, 99, getComputedStyle(document.documentElement).getPropertyValue("--uv-ext").trim()],
    ];

    const yTo = (y) => pad.t + (1 - (y / yMax)) * ph;

    for (const [a,b,color] of bands){
      const y0 = clamp(a, 0, yMax);
      const y1 = clamp(b, 0, yMax);
      if (y1 <= 0 || y0 >= yMax) continue;

      const top = yTo(y1);
      const bot = yTo(y0);
      const height = bot - top;

      ctx.fillStyle = color;
      ctx.fillRect(pad.l, top, pw, height);
    }
  }

  function clamp(x,a,b){ return Math.min(b, Math.max(a, x)); }

  function draw(series){
    const {times, values, yMaxRaw} = series;

    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    const pad = {l:56, r:18, t:18, b:44};
    const pw = w - pad.l - pad.r;
    const ph = h - pad.t - pad.b;

    const yMax = Math.ceil(yMaxRaw * 2) / 2; // round to 0.5
    const xMin = START_H, xMax = END_H;

    const xTo = (x) => pad.l + ((x - xMin) / (xMax - xMin)) * pw;
    const yTo = (y) => pad.t + (1 - (y / yMax)) * ph;

    // UV risk bands
    ctx.save();
    ctx.globalAlpha = 1;
    drawUvBands(pad, pw, ph, yMax);
    ctx.restore();

    // grid
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.fillStyle = "rgba(231,238,247,0.75)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

    const yStep = (yMax <= 4) ? 0.5 : (yMax <= 8 ? 1 : 2);
    for (let y=0; y<=yMax+1e-9; y+=yStep){
      const py = yTo(y);
      ctx.beginPath(); ctx.moveTo(pad.l, py); ctx.lineTo(w-pad.r, py); ctx.stroke();
      ctx.fillText(y.toFixed(yStep<1 ? 1 : 0), 10, py+4);
    }
    for (let x=START_H; x<=END_H; x++){
      const px = xTo(x);
      ctx.beginPath(); ctx.moveTo(px, pad.t); ctx.lineTo(px, h-pad.b); ctx.stroke();
      ctx.fillText(`${pad2(x)}:00`, px-18, h-16);
    }
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(pad.l, pad.t, pw, ph);
    ctx.restore();

    // line
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(86,182,194,0.95)";
    ctx.beginPath();
    for (let i=0;i<times.length;i++){
      const x = xTo(times[i]);
      const y = yTo(values[i]);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();

    // fill under curve
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(86,182,194,0.35)";
    ctx.beginPath();
    for (let i=0;i<times.length;i++){
      const x = xTo(times[i]);
      const y = yTo(values[i]);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.lineTo(xTo(xMax), yTo(0));
    ctx.lineTo(xTo(xMin), yTo(0));
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function updateSummary(series){
    latLon.textContent = `${state.lat.toFixed(4)}, ${state.lon.toFixed(4)}`;
    tzShow.textContent = (state.tz>=0?"+":"") + state.tz;
    maxUv.textContent = series.maxV.toFixed(1);
    maxTime.textContent = fmtTime(series.maxT);
  }

  function redraw(){
    try {
      kVal.textContent = Number(kRange.value).toFixed(1);
      nVal.textContent = Number(nRange.value).toFixed(2);

      const series = computeSeries();
      draw(series);
      updateSummary(series);
      setStatus(`Ritad (${series.step} min sampling).`);
    } catch (e) {
      setStatus(e.message || String(e), true);
    }
  }

  function requestGeo(){
    if (!navigator.geolocation){
      setStatus("Geolocation stöds inte i denna webbläsare.", true);
      return;
    }
    setStatus("Hämtar GPS-position…");
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        state.lat = pos.coords.latitude;
        state.lon = pos.coords.longitude;

        // UTC offset from device timezone (hours).
        // This assumes your device timezone matches your physical location (normally true).
        state.tz = -new Date().getTimezoneOffset() / 60;

        if (!dateInput.value) dateInput.value = todayLocalYMD();
        redraw();
      },
      (err) => setStatus(`Kunde inte hämta position: ${err.message}`, true),
      { enableHighAccuracy:true, timeout:12000, maximumAge:60000 }
    );
  }

  // ---- events ----
  geoBtn.addEventListener("click", requestGeo);
  redrawBtn.addEventListener("click", redraw);
  [dateInput, stepInput, kRange, nRange].forEach(x => x.addEventListener("input", redraw));

  // ---- init ----
  dateInput.value = todayLocalYMD();
  kVal.textContent = Number(kRange.value).toFixed(1);
  nVal.textContent = Number(nRange.value).toFixed(2);
})();
</script>
</body>
</html>