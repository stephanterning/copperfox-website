<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>UV-index (3 kurvor) 07–19</title>
  <style>
    :root{
      --bg:#0b0f14; --text:#e7eef7; --muted:#a9b7c6;
      --border:rgba(255,255,255,.09); --danger:#e06c75;
      --panelA:rgba(255,255,255,.04); --panelB:rgba(255,255,255,.02);

      /* UV band colors */
      --uv-low:   rgba(152,195,121,0.10); /* 0-2 */
      --uv-mod:   rgba(229,192,123,0.10); /* 3-5 */
      --uv-high:  rgba(224,108,117,0.10); /* 6-7 */
      --uv-vhigh: rgba(198,120,221,0.12); /* 8-10 */
      --uv-ext:   rgba(97,175,239,0.12);  /* 11+ */

      /* line colors */
      --line-clear: rgba(86,182,194,0.95);   /* Open-Meteo clear sky */
      --line-geo:   rgba(229,192,123,0.95);  /* geometry */
      --line-all:   rgba(224,108,117,0.95);  /* Open-Meteo all-sky */
    }
    *{box-sizing:border-box}
    body{
      margin:0; padding:18px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 20% 0%, rgba(86,182,194,.18), transparent 60%), var(--bg);
      color:var(--text);
    }
    .wrap{max-width:980px;margin:0 auto;display:grid;gap:14px}
    header{display:flex;flex-wrap:wrap;gap:10px 14px;align-items:baseline}
    h1{font-size:18px;margin:0}
    .tag{font-size:12px;color:var(--muted);border:1px solid var(--border);padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.03)}
    .panel{
      background:linear-gradient(180deg, var(--panelA), var(--panelB));
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px
    }
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;align-items:end}
    @media (max-width:700px){.row{grid-template-columns:1fr}}
    label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    input[type="date"], input[type="number"]{
      width:100%; padding:10px;
      border-radius:10px;border:1px solid var(--border);
      background:rgba(0,0,0,.25);color:var(--text);outline:none
    }
    input[type="range"]{width:100%}
    .btns{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
    button{
      cursor:pointer; border:1px solid var(--border);
      background:rgba(255,255,255,.04); color:var(--text);
      padding:10px 12px; border-radius:10px; font-weight:600;
    }
    button.primary{border-color:rgba(86,182,194,.55);background:rgba(86,182,194,.12)}
    button:hover{background:rgba(255,255,255,.07)}
    button.primary:hover{background:rgba(86,182,194,.18)}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .small{font-size:12px;color:var(--muted);line-height:1.4}
    .pill{
      display:flex;justify-content:space-between;gap:10px;align-items:center;
      padding:8px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,.03);
      font-size:12px;color:var(--muted)
    }
    canvas{
      width:100%; height:390px;
      background:rgba(0,0,0,.18);
      border:1px solid var(--border);
      border-radius:12px;
    }
    .status{font-size:12px;color:var(--muted)}
    .status.err{color:var(--danger)}

    details{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      background:rgba(0,0,0,.16);
      margin-top:12px;
    }
    summary{
      cursor:pointer;
      color:var(--text);
      font-weight:700;
      list-style:none;
      display:flex;
      align-items:center;
      gap:10px;
    }
    summary::-webkit-details-marker { display:none; }
    .chev{
      width:10px;height:10px;display:inline-block;
      border-right:2px solid rgba(231,238,247,.7);
      border-bottom:2px solid rgba(231,238,247,.7);
      transform:rotate(-45deg);
      margin-top:2px;
    }
    details[open] .chev{ transform:rotate(45deg); margin-top:0; }

    .advGrid{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width:700px){.advGrid{grid-template-columns:1fr}}

    .legend{
      display:flex; flex-wrap:wrap; gap:8px; margin-top:10px
    }
    .lg{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--border); background:rgba(255,255,255,.03);
      padding:6px 10px; border-radius:999px; font-size:12px; color:var(--muted)
    }
    .sw{width:10px;height:10px;border-radius:3px; display:inline-block}

    .curveToggles{
      display:flex; flex-wrap:wrap; gap:10px;
      margin-top:12px;
      padding-top:12px;
      border-top:1px dashed rgba(255,255,255,.12);
    }
    .chk{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      padding:8px 10px;
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      user-select:none;
    }
    .chk input{ transform: scale(1.1); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>UV-index 07:00–19:00 (3 kurvor)</h1>
      <span class="tag">Open-Meteo + geometri</span>
      <span class="tag">Jämför kurvorna själv</span>
    </header>

    <section class="panel">
      <div class="row">
        <label>
          Datum (lokal dag för platsen)
          <input id="dateInput" type="date" />
        </label>

        <div style="display:grid;gap:10px">
          <div class="btns" style="margin:0">
            <button class="primary" id="geoBtn">Hämta GPS-position</button>
            <button id="redrawBtn">Hämta & rita</button>
          </div>
          <div id="status" class="status">Redo. Tryck “Hämta GPS-position”.</div>
        </div>
      </div>

      <div class="curveToggles">
        <label class="chk">
          <input id="showClear" type="checkbox" checked />
          <span class="sw" style="background:var(--line-clear)"></span>
          Open-Meteo clear-sky
        </label>
        <label class="chk">
          <input id="showGeo" type="checkbox" checked />
          <span class="sw" style="background:var(--line-geo)"></span>
          Geometri
        </label>
        <label class="chk">
          <input id="showAll" type="checkbox" checked />
          <span class="sw" style="background:var(--line-all)"></span>
          Open-Meteo all-sky
        </label>
      </div>

      <details>
        <summary><span class="chev"></span> Avancerade inställningar</summary>

        <div class="advGrid">
          <label>
            Sampling (minuter)
            <input id="stepInput" type="number" min="5" max="60" step="5" value="10" />
            <span class="small">Open-Meteo är oftast timvärden. Vi interpolerar linjärt till detta steg.</span>
          </label>

          <div class="small">
            <b>Kurvorna</b><br/>
            • <span class="mono">uv_index_clear_sky</span> = klar-himmel (modell).<br/>
            • <span class="mono">uv_index</span> = “all-sky” (påverkas av moln m.m.).  [oai_citation:2‡Stack Overflow](https://stackoverflow.com/questions/76199673/unhandled-runtime-error-error-connector-http-error-bad-request?utm_source=chatgpt.com)<br/>
            • Geometri = förenklad form baserad på solhöjd.
          </div>

          <label>
            Geometri: K (skalning)
            <input id="kRange" type="range" min="6" max="18" step="0.1" value="11.0" />
            <span class="mono" id="kVal">11.0</span>
          </label>

          <label>
            Geometri: n (exponent)
            <input id="nRange" type="range" min="1.0" max="1.9" step="0.01" value="1.30" />
            <span class="mono" id="nVal">1.30</span>
          </label>

          <label style="grid-column:1/-1">
            <span class="chk" style="border-radius:12px;justify-content:flex-start;padding:10px 12px">
              <input id="autoK" type="checkbox" checked />
              Auto-kalibrera K så geometri-topp ≈ clear-sky max
            </span>
            <span class="small" style="margin-top:6px;display:block">
              Påverkar bara <b>nivån</b> på geometri-kurvan (inte formen). Stäng av om du vill styra K själv.
            </span>
          </label>

          <div class="small" style="grid-column:1/-1">
            <b>Geometri-modellen</b><br/>
            <span class="mono">UV = K · sin(elev)^n</span>, där <span class="mono">elev</span> är solens höjdvinkel.
            Detta är inte en full UV-modell (ozon/aerosol), utan en “form-approx”.
          </div>
        </div>

        <div class="legend">
          <div class="lg"><span class="sw" style="background:var(--uv-low)"></span>0–2 Låg</div>
          <div class="lg"><span class="sw" style="background:var(--uv-mod)"></span>3–5 Måttlig</div>
          <div class="lg"><span class="sw" style="background:var(--uv-high)"></span>6–7 Hög</div>
          <div class="lg"><span class="sw" style="background:var(--uv-vhigh)"></span>8–10 Mycket hög</div>
          <div class="lg"><span class="sw" style="background:var(--uv-ext)"></span>11+ Extrem</div>
        </div>
      </details>
    </section>

    <section class="panel">
      <div class="pill"><span>Lat / Lon</span><span class="mono" id="latLon">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>Timezone (API)</span><span class="mono" id="tzShow">—</span></div>

      <div class="pill" style="margin-top:10px;"><span>Max clear-sky (daily)</span><span class="mono" id="maxClear">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>Max all-sky (daily)</span><span class="mono" id="maxAll">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>Tid för max (≈, från valda kurvor)</span><span class="mono" id="maxTime">—</span></div>
    </section>

    <section class="panel">
      <canvas id="chart" width="1200" height="540"></canvas>
    </section>
  </div>

<script>
(() => {
  const el = (id) => document.getElementById(id);

  const dateInput = el("dateInput");
  const stepInput = el("stepInput");
  const geoBtn = el("geoBtn");
  const redrawBtn = el("redrawBtn");

  const showClear = el("showClear");
  const showGeo = el("showGeo");
  const showAll = el("showAll");

  const kRange = el("kRange");
  const nRange = el("nRange");
  const kVal = el("kVal");
  const nVal = el("nVal");
  const autoK = el("autoK");

  const latLon = el("latLon");
  const tzShow = el("tzShow");
  const maxClear = el("maxClear");
  const maxAll = el("maxAll");
  const maxTime = el("maxTime");
  const status = el("status");

  const canvas = el("chart");
  const ctx = canvas.getContext("2d");

  const START_H = 7;
  const END_H = 19;

  let state = { lat: null, lon: null };
  let inflight = null;

  function setStatus(msg, isErr=false){
    status.textContent = msg;
    status.classList.toggle("err", !!isErr);
  }
  function pad2(n){ return String(n).padStart(2,"0"); }
  function todayLocalYMD(){
    const d = new Date();
    return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  }
  function fmtLocalHHMMFromUtcSec(utcSec, offsetSec){
    const d = new Date((utcSec + offsetSec) * 1000);
    const hh = d.getUTCHours();
    const mm = d.getUTCMinutes();
    return `${pad2(hh)}:${pad2(mm)}`;
  }
  function localHoursFromUtcSec(utcSec, offsetSec){
    const d = new Date((utcSec + offsetSec) * 1000);
    return d.getUTCHours() + d.getUTCMinutes()/60;
  }

  // ---- Solar geometry approximation ----
  function dayOfYear(y,m,d){
    const dt = new Date(Date.UTC(y, m-1, d));
    const start = new Date(Date.UTC(y, 0, 1));
    return Math.floor((dt - start)/86400000) + 1;
  }

  function solarElevationDeg(localClockHours, latDeg, lonDeg, tzHours, y, m, d){
    const doy = dayOfYear(y,m,d);
    const gamma = 2 * Math.PI / 365 * (doy - 1 + (localClockHours - 12) / 24);

    const decl =
      0.006918
      - 0.399912 * Math.cos(gamma)
      + 0.070257 * Math.sin(gamma)
      - 0.006758 * Math.cos(2 * gamma)
      + 0.000907 * Math.sin(2 * gamma)
      - 0.002697 * Math.cos(3 * gamma)
      + 0.00148  * Math.sin(3 * gamma);

    const eqtime =
      229.18 * (
        0.000075
        + 0.001868 * Math.cos(gamma)
        - 0.032077 * Math.sin(gamma)
        - 0.014615 * Math.cos(2 * gamma)
        - 0.040849 * Math.sin(2 * gamma)
      );

    const minutes = localClockHours * 60;
    const tst = minutes + eqtime + 4 * lonDeg - 60 * tzHours;
    const haDeg = (tst / 4) - 180;
    const ha = haDeg * Math.PI / 180;

    const lat = latDeg * Math.PI / 180;
    const elevRad = Math.asin(
      Math.sin(lat) * Math.sin(decl) +
      Math.cos(lat) * Math.cos(decl) * Math.cos(ha)
    );

    return elevRad * 180 / Math.PI;
  }

  function uvFromElevation(elevDeg, K, n){
    if (elevDeg <= 0) return 0;
    const s = Math.sin(elevDeg * Math.PI / 180);
    return K * Math.pow(Math.max(0, s), n);
  }

  // ---- Chart helpers ----
  function clamp(x,a,b){ return Math.min(b, Math.max(a, x)); }

  function drawUvBands(pad, pw, ph, yMax){
    const styles = getComputedStyle(document.documentElement);
    const bands = [
      [0, 2,  styles.getPropertyValue("--uv-low").trim()],
      [2, 5,  styles.getPropertyValue("--uv-mod").trim()],
      [5, 7,  styles.getPropertyValue("--uv-high").trim()],
      [7, 10, styles.getPropertyValue("--uv-vhigh").trim()],
      [10, 99, styles.getPropertyValue("--uv-ext").trim()],
    ];
    const yTo = (y) => pad.t + (1 - (y / yMax)) * ph;

    for (const [a,b,color] of bands){
      const y0 = clamp(a, 0, yMax);
      const y1 = clamp(b, 0, yMax);
      if (y1 <= 0 || y0 >= yMax) continue;

      const top = yTo(y1);
      const bot = yTo(y0);
      ctx.fillStyle = color;
      ctx.fillRect(pad.l, top, pw, bot - top);
    }
  }

  function drawGrid(pad, w, h, pw, ph, yMax){
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.fillStyle = "rgba(231,238,247,0.75)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

    const yTo = (y) => pad.t + (1 - (y / yMax)) * ph;

    const yStep = (yMax <= 4) ? 0.5 : (yMax <= 8 ? 1 : 2);
    for (let y=0; y<=yMax+1e-9; y+=yStep){
      const py = yTo(y);
      ctx.beginPath(); ctx.moveTo(pad.l, py); ctx.lineTo(w-pad.r, py); ctx.stroke();
      ctx.fillText(y.toFixed(yStep<1 ? 1 : 0), 10, py+4);
    }

    for (let x=START_H; x<=END_H; x++){
      const px = pad.l + ((x - START_H) / (END_H - START_H)) * pw;
      ctx.beginPath(); ctx.moveTo(px, pad.t); ctx.lineTo(px, h-pad.b); ctx.stroke();
      ctx.fillText(`${pad2(x)}:00`, px-18, h-16);
    }

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(pad.l, pad.t, pw, ph);
    ctx.restore();
  }

  function drawLine(timesH, values, color, yMax){
    const w = canvas.width, h = canvas.height;
    const pad = {l:56, r:18, t:18, b:44};
    const pw = w - pad.l - pad.r;
    const ph = h - pad.t - pad.b;

    const xTo = (x) => pad.l + ((x - START_H) / (END_H - START_H)) * pw;
    const yTo = (y) => pad.t + (1 - (y / yMax)) * ph;

    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = color;
    ctx.beginPath();
    for (let i=0;i<timesH.length;i++){
      const x = xTo(timesH[i]);
      const y = yTo(values[i]);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function linearInterpAt(tSec, xsSec, ys){
    if (tSec <= xsSec[0]) return ys[0];
    const last = xsSec.length - 1;
    if (tSec >= xsSec[last]) return ys[last];

    let lo = 0, hi = last;
    while (hi - lo > 1) {
      const mid = (lo + hi) >> 1;
      if (xsSec[mid] <= tSec) lo = mid; else hi = mid;
    }
    const t0 = xsSec[lo], t1 = xsSec[hi];
    const y0 = ys[lo], y1 = ys[hi];
    const f = (tSec - t0) / (t1 - t0);
    return y0 + f * (y1 - y0);
  }

  async function fetchOpenMeteo(lat, lon, ymd){
    const url = new URL("https://api.open-meteo.com/v1/forecast");
    url.searchParams.set("latitude", String(lat));
    url.searchParams.set("longitude", String(lon));

    // 3 curves source:
    // - hourly uv_index (all-sky)
    // - hourly uv_index_clear_sky
    // - geometry is computed locally
    url.searchParams.set("hourly", "uv_index,uv_index_clear_sky");

    // daily max for both
    url.searchParams.set("daily", "uv_index_max,uv_index_clear_sky_max");

    url.searchParams.set("timezone", "auto");
    url.searchParams.set("timeformat", "unixtime");
    url.searchParams.set("start_date", ymd);
    url.searchParams.set("end_date", ymd);

    if (inflight) inflight.abort();
    inflight = new AbortController();

    const res = await fetch(url.toString(), { signal: inflight.signal });
    if (!res.ok) throw new Error(`Open-Meteo fel: HTTP ${res.status}`);
    const data = await res.json();

    const tzName = data.timezone || "—";
    const offsetSec = Number(data.utc_offset_seconds ?? 0);

    const t = data?.hourly?.time;
    const uvAll = data?.hourly?.uv_index;
    const uvClear = data?.hourly?.uv_index_clear_sky;

    if (!Array.isArray(t) || !Array.isArray(uvAll) || !Array.isArray(uvClear) ||
        t.length !== uvAll.length || t.length !== uvClear.length) {
      throw new Error("Ovväntat svarformat från Open-Meteo (hourly).");
    }

    const dMaxAllArr = data?.daily?.uv_index_max;
    const dMaxClearArr = data?.daily?.uv_index_clear_sky_max;
    const dailyMaxAll = Array.isArray(dMaxAllArr) ? dMaxAllArr[0] : null;
    const dailyMaxClear = Array.isArray(dMaxClearArr) ? dMaxClearArr[0] : null;

    return {
      tzName,
      offsetSec,
      xsSec: t.map(Number),
      uvAll: uvAll.map(Number),
      uvClear: uvClear.map(Number),
      dailyMaxAll,
      dailyMaxClear
    };
  }

  function drawAll(timesH, series){
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    const pad = {l:56, r:18, t:18, b:44};
    const pw = w - pad.l - pad.r;
    const ph = h - pad.t - pad.b;

    const allVals = [];
    if (showClear.checked) allVals.push(...series.clear);
    if (showAll.checked)   allVals.push(...series.all);
    if (showGeo.checked)   allVals.push(...series.geo);

    const yMaxRaw = Math.max(1, ...allVals.filter(v => Number.isFinite(v)));
    const yMax = Math.ceil(yMaxRaw * 2) / 2;

    drawUvBands(pad, pw, ph, yMax);
    drawGrid(pad, w, h, pw, ph, yMax);

    const styles = getComputedStyle(document.documentElement);
    if (showClear.checked) drawLine(timesH, series.clear, styles.getPropertyValue("--line-clear").trim(), yMax);
    if (showGeo.checked)   drawLine(timesH, series.geo,   styles.getPropertyValue("--line-geo").trim(), yMax);
    if (showAll.checked)   drawLine(timesH, series.all,   styles.getPropertyValue("--line-all").trim(), yMax);
  }

  async function redraw(){
    try {
      kVal.textContent = Number(kRange.value).toFixed(1);
      nVal.textContent = Number(nRange.value).toFixed(2);

      if (!Number.isFinite(state.lat) || !Number.isFinite(state.lon)) {
        throw new Error("Ingen GPS-position ännu.");
      }
      const ymd = dateInput.value;
      const stepMin = Math.max(5, Math.min(60, Number(stepInput.value) || 10));

      setStatus("Hämtar Open-Meteo (uv_index + uv_index_clear_sky)…");

      const { tzName, offsetSec, xsSec, uvAll, uvClear, dailyMaxAll, dailyMaxClear } =
        await fetchOpenMeteo(state.lat, state.lon, ymd);

      // Build UTC timeline for local 07:00–19:00 at location:
      const [yy, mm, dd] = ymd.split("-").map(Number);
      const startUtcSec = Math.floor(Date.UTC(yy, mm-1, dd, START_H, 0, 0) / 1000) - offsetSec;
      const endUtcSec   = Math.floor(Date.UTC(yy, mm-1, dd, END_H,   0, 0) / 1000) - offsetSec;

      const timesH = [];
      const series = { clear: [], all: [], geo: [] };

      let K = Number(kRange.value);
      const n = Number(nRange.value);
      const tzHours = offsetSec / 3600;

      for (let t = startUtcSec; t <= endUtcSec; t += stepMin * 60) {
        const localH = localHoursFromUtcSec(t, offsetSec);
        timesH.push(localH);

        const c = linearInterpAt(t, xsSec, uvClear);
        const a = linearInterpAt(t, xsSec, uvAll);

        series.clear.push(Math.max(0, c));
        series.all.push(Math.max(0, a));

        const elev = solarElevationDeg(localH, state.lat, state.lon, tzHours, yy, mm, dd);
        series.geo.push(Math.max(0, uvFromElevation(elev, K, n)));
      }

      // Optional: auto-calibrate K to match geometry peak to clear-sky peak
      if (autoK.checked) {
        const targetPeak = (typeof dailyMaxClear === "number" && Number.isFinite(dailyMaxClear))
          ? dailyMaxClear
          : Math.max(...series.clear);

        const geoPeak = Math.max(...series.geo);
        if (geoPeak > 0 && Number.isFinite(targetPeak) && targetPeak > 0) {
          const factor = targetPeak / geoPeak;
          K = K * factor;

          series.geo = [];
          for (let i=0;i<timesH.length;i++){
            const localH = timesH[i];
            const elev = solarElevationDeg(localH, state.lat, state.lon, tzHours, yy, mm, dd);
            series.geo.push(Math.max(0, uvFromElevation(elev, K, n)));
          }

          // show effective K within slider bounds
          const clampedK = Math.max(Number(kRange.min), Math.min(Number(kRange.max), K));
          kRange.value = String(clampedK);
          kVal.textContent = Number(kRange.value).toFixed(1);
        }
      }

      // Display max values (daily if available)
      const hasDailyClear = (typeof dailyMaxClear === "number" && Number.isFinite(dailyMaxClear));
      const hasDailyAll = (typeof dailyMaxAll === "number" && Number.isFinite(dailyMaxAll));

      maxClear.textContent = (hasDailyClear ? dailyMaxClear : Math.max(...series.clear)).toFixed(1);
      maxAll.textContent = (hasDailyAll ? dailyMaxAll : Math.max(...series.all)).toFixed(1);

      // Time-of-max: choose max among enabled curves, based on our sampled curves
      let bestIdx = 0, bestVal = -1;
      for (let i=0;i<timesH.length;i++){
        const candidates = [];
        if (showClear.checked) candidates.push(series.clear[i]);
        if (showAll.checked)   candidates.push(series.all[i]);
        if (showGeo.checked)   candidates.push(series.geo[i]);
        const v = Math.max(...candidates);
        if (v > bestVal) { bestVal = v; bestIdx = i; }
      }
      const tBestUtcSec = startUtcSec + bestIdx * stepMin * 60;
      maxTime.textContent = fmtLocalHHMMFromUtcSec(tBestUtcSec, offsetSec);

      // UI
      latLon.textContent = `${state.lat.toFixed(4)}, ${state.lon.toFixed(4)}`;
      tzShow.textContent = tzName;

      drawAll(timesH, series);
      setStatus(`Ritad (${stepMin} min).`);
    } catch (e) {
      if (e?.name === "AbortError") return;
      setStatus(e.message || String(e), true);
    }
  }

  function requestGeo(){
    if (!navigator.geolocation){
      setStatus("Geolocation stöds inte i denna webbläsare.", true);
      return;
    }
    setStatus("Hämtar GPS-position…");
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        state.lat = pos.coords.latitude;
        state.lon = pos.coords.longitude;
        redraw();
      },
      (err) => setStatus(`Kunde inte hämta position: ${err.message}`, true),
      { enableHighAccuracy:true, timeout:12000, maximumAge:60000 }
    );
  }

  geoBtn.addEventListener("click", requestGeo);
  redrawBtn.addEventListener("click", redraw);
  [dateInput, stepInput, showClear, showGeo, showAll, kRange, nRange, autoK]
    .forEach(x => x.addEventListener("input", redraw));

  dateInput.value = todayLocalYMD();
  kVal.textContent = Number(kRange.value).toFixed(1);
  nVal.textContent = Number(nRange.value).toFixed(2);
})();
</script>
</body>
</html>