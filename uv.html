<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>UV-index</title>
  <style>
    :root{
      --bg:#0b0f14; --text:#e7eef7; --muted:#a9b7c6;
      --border:rgba(255,255,255,.10); --danger:#e06c75;
      --panelA:rgba(255,255,255,.04); --panelB:rgba(255,255,255,.02);

      --uv-low:   rgba(152,195,121,0.10);
      --uv-mod:   rgba(229,192,123,0.10);
      --uv-high:  rgba(224,108,117,0.10);
      --uv-vhigh: rgba(198,120,221,0.12);
      --uv-ext:   rgba(97,175,239,0.12);

      --line-clear: rgba(86,182,194,0.95);
      --line-geo:   rgba(229,192,123,0.95);
      --line-all:   rgba(224,108,117,0.95);
    }

    *{box-sizing:border-box}
    body{
      margin:0; padding:16px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 20% 0%, rgba(86,182,194,.18), transparent 60%), var(--bg);
      color:var(--text);
    }
    .wrap{max-width:980px;margin:0 auto;display:grid;gap:12px}

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:2px;
    }
    h1{font-size:18px;margin:0}

    .panel{
      background:linear-gradient(180deg, var(--panelA), var(--panelB));
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px;
    }

    label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    input[type="date"], input[type="text"], input[type="number"]{
      width:100%;
      padding:10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--text);
      outline:none;
    }

    .row2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      align-items:end;
    }
    @media (max-width:700px){ .row2{grid-template-columns:1fr} }

    .placeRow{
      display:grid;
      grid-template-columns: 1fr 44px;
      gap:10px;
      align-items:end;
    }

    button{
      cursor:pointer;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
      color:var(--text);
      padding:10px 12px;
      border-radius:10px;
      font-weight:700;
    }
    button:hover{background:rgba(255,255,255,.07)}
    button.primary{border-color:rgba(86,182,194,.55);background:rgba(86,182,194,.12)}
    button.primary:hover{background:rgba(86,182,194,.18)}
    .iconBtn{
      display:flex; align-items:center; justify-content:center;
      padding:10px;
      height:42px;
      width:44px;
      border-radius:10px;
      font-size:18px;
      line-height:1;
    }
    .updateRow{ margin-top:10px; }
    .status{font-size:12px;color:var(--muted);margin-top:10px}
    .status.err{color:var(--danger)}

    .curveToggles{
      display:flex; flex-wrap:wrap; gap:10px;
      margin-bottom:10px;
    }
    .chk{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      padding:8px 10px;
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      user-select:none;
    }
    .chk input{ transform: scale(1.1); }
    .sw{width:10px;height:10px;border-radius:3px; display:inline-block}

    canvas{
      width:100%;
      height:390px;
      background:rgba(0,0,0,.18);
      border:1px solid var(--border);
      border-radius:12px;
    }

    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .small{font-size:12px;color:var(--muted);line-height:1.4}

    details{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      background:rgba(0,0,0,.16);
    }
    summary{
      cursor:pointer;
      color:var(--text);
      font-weight:800;
      list-style:none;
      display:flex;
      align-items:center;
      gap:10px;
    }
    summary::-webkit-details-marker{ display:none; }

    .gear details{
      padding:0;
      border:none;
      background:transparent;
    }
    .gear summary{
      padding:8px 10px;
      border:1px solid var(--border);
      border-radius:12px;
      background:rgba(255,255,255,.03);
      font-weight:800;
      color:var(--text);
    }
    .gearPanel{
      margin-top:10px;
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      background:rgba(0,0,0,.18);
      width:min(520px, 92vw);
    }

    .advGrid{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width:700px){.advGrid{grid-template-columns:1fr}}
    input[type="range"]{width:100%}

    .pillGrid{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width:700px){.pillGrid{grid-template-columns:1fr}}
    .pill{
      display:flex;justify-content:space-between;gap:10px;align-items:center;
      padding:8px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,.03);
      font-size:12px;color:var(--muted)
    }

    .legend{
      display:flex; flex-wrap:wrap; gap:8px; margin-top:10px
    }
    .lg{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--border); background:rgba(255,255,255,.03);
      padding:6px 10px; border-radius:999px; font-size:12px; color:var(--muted)
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1>UV-index</h1>

      <div class="gear">
        <details id="advDetails">
          <summary title="Avancerade inställningar" aria-label="Avancerade inställningar">⚙️</summary>
          <div class="gearPanel">
            <div class="small">
              <b>Kurvorna</b><br/>
              • <span class="mono">Open-Meteo clear-sky</span> = <span class="mono">uv_index_clear_sky</span><br/>
              • <span class="mono">Open-Meteo all-sky</span> = <span class="mono">uv_index</span> (moln m.m.)<br/>
              • <span class="mono">Geometri</span> = <span class="mono">UV = K · sin(elev)^n</span>
            </div>

            <div class="advGrid">
              <label>
                Sampling (minuter)
                <input id="stepInput" type="number" min="5" max="60" step="5" value="10" />
                <span class="small">API:t är ofta timvärden; vi interpolerar linjärt till detta steg.</span>
              </label>

              <div class="small">
                <b>Kalibrering</b><br/>
                När “K matchar clear-sky max” är på räknar vi ut
                <span class="mono">scale = clearPeak / geoPeak</span> och använder
                <span class="mono">K_eff = K · scale</span> <i>endast</i> för geometri-kurvan.
              </div>

              <label>
                Geometri: K
                <input id="kRange" type="range" min="6" max="18" step="0.1" value="13.0" />
                <span class="mono" id="kVal">13.0</span>
              </label>

              <label>
                Geometri: n
                <input id="nRange" type="range" min="1.0" max="1.9" step="0.01" value="1.30" />
                <span class="mono" id="nVal">1.30</span>
              </label>

              <label style="grid-column:1/-1">
                <span class="chk" style="border-radius:12px;justify-content:flex-start;padding:10px 12px">
                  <input id="autoK" type="checkbox" />
                  K matchar clear-sky max (jämför form på samma skala)
                </span>
              </label>
            </div>

            <div class="legend">
              <div class="lg"><span class="sw" style="background:var(--uv-low)"></span>0–2 Låg</div>
              <div class="lg"><span class="sw" style="background:var(--uv-mod)"></span>3–5 Måttlig</div>
              <div class="lg"><span class="sw" style="background:var(--uv-high)"></span>6–7 Hög</div>
              <div class="lg"><span class="sw" style="background:var(--uv-vhigh)"></span>8–10 Mycket hög</div>
              <div class="lg"><span class="sw" style="background:var(--uv-ext)"></span>11+ Extrem</div>
            </div>
          </div>
        </details>
      </div>
    </div>

    <section class="panel">
      <div class="row2">
        <label>
          Datum
          <input id="dateInput" type="date" />
        </label>

        <label>
          Plats
          <div class="placeRow">
            <input
              id="placeInput"
              type="text"
              placeholder="Sök stad eller skriv lat lon"
              list="placeDatalist"
              autocomplete="off"
              spellcheck="false"
            />
            <datalist id="placeDatalist"></datalist>
            <button class="iconBtn primary" id="gpsBtn" title="Hämta GPS" aria-label="Hämta GPS">⌖</button>
          </div>
          <span class="small">
            Skriv t.ex. <span class="mono">Stockholm</span> eller koordinater som <span class="mono">7.6253 99.0324</span> / <span class="mono">7.6253, 99.0324</span>.
          </span>
        </label>
      </div>

      <div class="updateRow">
        <button class="primary" id="updateBtn" style="width:100%">Uppdatera</button>
        <div id="status" class="status">Redo.</div>
      </div>
    </section>

    <section class="panel">
      <div class="curveToggles">
        <label class="chk">
          <input id="showClear" type="checkbox" checked />
          <span class="sw" style="background:var(--line-clear)"></span>
          Clear sky
        </label>
        <label class="chk">
          <input id="showGeo" type="checkbox" checked />
          <span class="sw" style="background:var(--line-geo)"></span>
          Geometri
        </label>
        <label class="chk">
          <input id="showAll" type="checkbox" checked />
          <span class="sw" style="background:var(--line-all)"></span>
          All-sky
        </label>
      </div>

      <canvas id="chart" width="1200" height="540"></canvas>
    </section>

    <details class="panel" id="moreInfoDetails">
      <summary>Mer info</summary>

      <div class="pillGrid">
        <div class="pill"><span>Timezone (API)</span><span class="mono" id="tzShow">—</span></div>
        <div class="pill"><span>Lat / Lon</span><span class="mono" id="latLon">—</span></div>

        <div class="pill"><span>Max clear-sky (daily)</span><span class="mono" id="maxClear">—</span></div>
        <div class="pill"><span>Max all-sky (daily)</span><span class="mono" id="maxAll">—</span></div>

        <div class="pill"><span>Geometri max (kurva)</span><span class="mono" id="maxGeo">—</span></div>
        <div class="pill"><span>Tid för max (≈, valda)</span><span class="mono" id="maxTime">—</span></div>

        <div class="pill"><span>K</span><span class="mono" id="kUserShow">—</span></div>
        <div class="pill"><span>K (effektiv)</span><span class="mono" id="kEff">—</span></div>

        <div class="pill"><span>Skalning (scale)</span><span class="mono" id="scaleShow">—</span></div>
        <div class="pill"><span>Sampling</span><span class="mono" id="samplingShow">—</span></div>
      </div>

      <div class="small" style="margin-top:10px">
        “Tid för max” kommer från de interpolerade kurvorna i grafen (och blir därför ungefärlig).
      </div>
    </details>
  </div>

<script>
(() => {
  const el = (id) => document.getElementById(id);

  const dateInput  = el("dateInput");
  const placeInput = el("placeInput");
  const placeDatalist = el("placeDatalist");
  const gpsBtn     = el("gpsBtn");
  const updateBtn  = el("updateBtn");

  const showClear = el("showClear");
  const showGeo   = el("showGeo");
  const showAll   = el("showAll");

  const stepInput = el("stepInput");
  const kRange = el("kRange");
  const nRange = el("nRange");
  const kVal = el("kVal");
  const nVal = el("nVal");
  const autoK = el("autoK");

  const tzShow = el("tzShow");
  const latLon = el("latLon");
  const maxClear = el("maxClear");
  const maxAll = el("maxAll");
  const maxGeo = el("maxGeo");
  const maxTime = el("maxTime");
  const kEff = el("kEff");
  const scaleShow = el("scaleShow");
  const kUserShow = el("kUserShow");
  const samplingShow = el("samplingShow");

  const status = el("status");

  const canvas = el("chart");
  const ctx = canvas.getContext("2d");

  const START_H = 7;
  const END_H = 19;

  let inflightForecast = null;
  let inflightGeo = null;

  // Latest suggestions (displayName -> payload)
  const suggestionMap = new Map();

  function setStatus(msg, isErr=false){
    status.textContent = msg;
    status.classList.toggle("err", !!isErr);
  }
  function pad2(n){ return String(n).padStart(2,"0"); }
  function todayLocalYMD(){
    const d = new Date();
    return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  }

  function parseLatLon(text){
    // Accept "lat, lon" or "lat lon" (one+ whitespace)
    const s = String(text).trim();
    const m = s.match(/^(-?\d+(?:\.\d+)?)\s*(?:,|\s+)\s*(-?\d+(?:\.\d+)?)$/);
    if (!m) return null;
    const lat = Number(m[1]);
    const lon = Number(m[2]);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return null;
    return { lat, lon };
  }

  function fmtLocalHHMMFromUtcSec(utcSec, offsetSec){
    const d = new Date((utcSec + offsetSec) * 1000);
    const hh = d.getUTCHours();
    const mm = d.getUTCMinutes();
    return `${pad2(hh)}:${pad2(mm)}`;
  }
  function localHoursFromUtcSec(utcSec, offsetSec){
    const d = new Date((utcSec + offsetSec) * 1000);
    return d.getUTCHours() + d.getUTCMinutes()/60;
  }

  // --- Solar geometry approximation ---
  function dayOfYear(y,m,d){
    const dt = new Date(Date.UTC(y, m-1, d));
    const start = new Date(Date.UTC(y, 0, 1));
    return Math.floor((dt - start)/86400000) + 1;
  }

  function solarElevationDeg(localClockHours, latDeg, lonDeg, tzHours, y, m, d){
    const doy = dayOfYear(y,m,d);
    const gamma = 2 * Math.PI / 365 * (doy - 1 + (localClockHours - 12) / 24);

    const decl =
      0.006918
      - 0.399912 * Math.cos(gamma)
      + 0.070257 * Math.sin(gamma)
      - 0.006758 * Math.cos(2 * gamma)
      + 0.000907 * Math.sin(2 * gamma)
      - 0.002697 * Math.cos(3 * gamma)
      + 0.00148  * Math.sin(3 * gamma);

    const eqtime =
      229.18 * (
        0.000075
        + 0.001868 * Math.cos(gamma)
        - 0.032077 * Math.sin(gamma)
        - 0.014615 * Math.cos(2 * gamma)
        - 0.040849 * Math.sin(2 * gamma)
      );

    const minutes = localClockHours * 60;
    const tst = minutes + eqtime + 4 * lonDeg - 60 * tzHours;
    const haDeg = (tst / 4) - 180;
    const ha = haDeg * Math.PI / 180;

    const lat = latDeg * Math.PI / 180;
    const elevRad = Math.asin(
      Math.sin(lat) * Math.sin(decl) +
      Math.cos(lat) * Math.cos(decl) * Math.cos(ha)
    );
    return elevRad * 180 / Math.PI;
  }

  function uvFromElevation(elevDeg, K, n){
    if (elevDeg <= 0) return 0;
    const s = Math.sin(elevDeg * Math.PI / 180);
    return K * Math.pow(Math.max(0, s), n);
  }

  // --- Chart helpers ---
  function clamp(x,a,b){ return Math.min(b, Math.max(a, x)); }

  function drawUvBands(pad, pw, ph, yMax){
    const styles = getComputedStyle(document.documentElement);
    const bands = [
      [0, 2,  styles.getPropertyValue("--uv-low").trim()],
      [2, 5,  styles.getPropertyValue("--uv-mod").trim()],
      [5, 7,  styles.getPropertyValue("--uv-high").trim()],
      [7, 10, styles.getPropertyValue("--uv-vhigh").trim()],
      [10, 99, styles.getPropertyValue("--uv-ext").trim()],
    ];
    const yTo = (y) => pad.t + (1 - (y / yMax)) * ph;

    for (const [a,b,color] of bands){
      const y0 = clamp(a, 0, yMax);
      const y1 = clamp(b, 0, yMax);
      if (y1 <= 0 || y0 >= yMax) continue;

      const top = yTo(y1);
      const bot = yTo(y0);
      ctx.fillStyle = color;
      ctx.fillRect(pad.l, top, pw, bot - top);
    }
  }

  function drawGrid(pad, w, h, pw, ph, yMax){
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.fillStyle = "rgba(231,238,247,0.75)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

    const yTo = (y) => pad.t + (1 - (y / yMax)) * ph;

    const yStep = (yMax <= 4) ? 0.5 : (yMax <= 8 ? 1 : 2);
    for (let y=0; y<=yMax+1e-9; y+=yStep){
      const py = yTo(y);
      ctx.beginPath(); ctx.moveTo(pad.l, py); ctx.lineTo(w-pad.r, py); ctx.stroke();
      ctx.fillText(y.toFixed(yStep<1 ? 1 : 0), 10, py+4);
    }

    for (let x=START_H; x<=END_H; x++){
      const px = pad.l + ((x - START_H) / (END_H - START_H)) * pw;
      ctx.beginPath(); ctx.moveTo(px, pad.t); ctx.lineTo(px, h-pad.b); ctx.stroke();
      ctx.fillText(`${pad2(x)}:00`, px-18, h-16);
    }

    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(pad.l, pad.t, pw, ph);
    ctx.restore();
  }

  function drawLine(timesH, values, color, yMax){
    const w = canvas.width, h = canvas.height;
    const pad = {l:56, r:18, t:18, b:44};
    const pw = w - pad.l - pad.r;
    const ph = h - pad.t - pad.b;

    const xTo = (x) => pad.l + ((x - START_H) / (END_H - START_H)) * pw;
    const yTo = (y) => pad.t + (1 - (y / yMax)) * ph;

    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = color;
    ctx.beginPath();
    for (let i=0;i<timesH.length;i++){
      const x = xTo(timesH[i]);
      const y = yTo(values[i]);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function linearInterpAt(tSec, xsSec, ys){
    if (tSec <= xsSec[0]) return ys[0];
    const last = xsSec.length - 1;
    if (tSec >= xsSec[last]) return ys[last];

    let lo = 0, hi = last;
    while (hi - lo > 1) {
      const mid = (lo + hi) >> 1;
      if (xsSec[mid] <= tSec) lo = mid; else hi = mid;
    }
    const t0 = xsSec[lo], t1 = xsSec[hi];
    const y0 = ys[lo], y1 = ys[hi];
    const f = (tSec - t0) / (t1 - t0);
    return y0 + f * (y1 - y0);
  }

  function drawAll(timesH, series){
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    const pad = {l:56, r:18, t:18, b:44};
    const pw = w - pad.l - pad.r;
    const ph = h - pad.t - pad.b;

    const allVals = [];
    if (showClear.checked) allVals.push(...series.clear);
    if (showAll.checked)   allVals.push(...series.all);
    if (showGeo.checked)   allVals.push(...series.geo);

    const yMaxRaw = Math.max(1, ...allVals.filter(v => Number.isFinite(v)));
    const yMax = Math.ceil(yMaxRaw * 2) / 2;

    drawUvBands(pad, pw, ph, yMax);
    drawGrid(pad, w, h, pw, ph, yMax);

    const styles = getComputedStyle(document.documentElement);
    if (showClear.checked) drawLine(timesH, series.clear, styles.getPropertyValue("--line-clear").trim(), yMax);
    if (showGeo.checked)   drawLine(timesH, series.geo,   styles.getPropertyValue("--line-geo").trim(), yMax);
    if (showAll.checked)   drawLine(timesH, series.all,   styles.getPropertyValue("--line-all").trim(), yMax);
  }

  // --- Open-Meteo geocoding ---
  function formatPlace(r){
    const parts = [];
    if (r?.name) parts.push(r.name);
    // admin1 is often state/region; avoid duplicates like "Berlin, Berlin"
    const admin1 = (r?.admin1 && r.admin1 !== r.name) ? r.admin1 : "";
    if (admin1) parts.push(admin1);
    if (r?.country) parts.push(r.country);
    return parts.join(", ");
  }

  async function geocode(query){
    const q = String(query || "").trim();
    if (q.length < 2) return [];

    const url = new URL("https://geocoding-api.open-meteo.com/v1/search");
    url.searchParams.set("name", q);
    url.searchParams.set("count", "10");
    url.searchParams.set("language", "sv");
    url.searchParams.set("format", "json");

    if (inflightGeo) inflightGeo.abort();
    inflightGeo = new AbortController();

    const res = await fetch(url.toString(), { signal: inflightGeo.signal });
    if (!res.ok) return [];
    const data = await res.json();
    const results = Array.isArray(data?.results) ? data.results : [];
    return results
      .filter(r => Number.isFinite(r?.latitude) && Number.isFinite(r?.longitude))
      .map(r => ({
        display: formatPlace(r),
        lat: Number(r.latitude),
        lon: Number(r.longitude),
        raw: r
      }));
  }

  function setDatalist(suggestions){
    suggestionMap.clear();
    placeDatalist.innerHTML = "";
    for (const s of suggestions){
      const opt = document.createElement("option");
      opt.value = s.display;
      placeDatalist.appendChild(opt);
      suggestionMap.set(s.display, { lat: s.lat, lon: s.lon, display: s.display });
    }
  }

  let debounceT = null;
  function onPlaceInput(){
    const q = placeInput.value.trim();
    // if coords, do not suggest
    if (parseLatLon(q)) {
      setDatalist([]);
      return;
    }
    clearTimeout(debounceT);
    debounceT = setTimeout(async () => {
      try{
        if (q.trim().length < 2) { setDatalist([]); return; }
        const res = await geocode(q);
        setDatalist(res);
      } catch {
        // ignore
      }
    }, 250);
  }

  // --- Open-Meteo forecast ---
  async function fetchOpenMeteoForecast(lat, lon, ymd){
    const url = new URL("https://api.open-meteo.com/v1/forecast");
    url.searchParams.set("latitude", String(lat));
    url.searchParams.set("longitude", String(lon));
    url.searchParams.set("hourly", "uv_index,uv_index_clear_sky");
    url.searchParams.set("daily", "uv_index_max,uv_index_clear_sky_max");
    url.searchParams.set("timezone", "auto");
    url.searchParams.set("timeformat", "unixtime");
    url.searchParams.set("start_date", ymd);
    url.searchParams.set("end_date", ymd);

    if (inflightForecast) inflightForecast.abort();
    inflightForecast = new AbortController();

    const res = await fetch(url.toString(), { signal: inflightForecast.signal });
    if (!res.ok) throw new Error(`Open-Meteo fel: HTTP ${res.status}`);
    const data = await res.json();

    const tzName = data.timezone || "—";
    const offsetSec = Number(data.utc_offset_seconds ?? 0);

    const t = data?.hourly?.time;
    const uvAll = data?.hourly?.uv_index;
    const uvClear = data?.hourly?.uv_index_clear_sky;

    if (!Array.isArray(t) || !Array.isArray(uvAll) || !Array.isArray(uvClear) ||
        t.length !== uvAll.length || t.length !== uvClear.length) {
      throw new Error("Ovväntat svarformat från Open-Meteo (hourly).");
    }

    const dMaxAllArr = data?.daily?.uv_index_max;
    const dMaxClearArr = data?.daily?.uv_index_clear_sky_max;

    const dailyMaxAll = Array.isArray(dMaxAllArr) ? dMaxAllArr[0] : null;
    const dailyMaxClear = Array.isArray(dMaxClearArr) ? dMaxClearArr[0] : null;

    return {
      tzName,
      offsetSec,
      xsSec: t.map(Number),
      uvAll: uvAll.map(Number),
      uvClear: uvClear.map(Number),
      dailyMaxAll,
      dailyMaxClear
    };
  }

  async function resolvePlaceToCoords(){
    const txt = placeInput.value.trim();

    // 1) coords typed
    const coords = parseLatLon(txt);
    if (coords) return { ...coords, display: `${coords.lat.toFixed(4)}, ${coords.lon.toFixed(4)}`, source: "coords" };

    // 2) selected suggestion
    if (suggestionMap.has(txt)) {
      const s = suggestionMap.get(txt);
      return { lat: s.lat, lon: s.lon, display: s.display, source: "suggestion" };
    }

    // 3) geocode on-demand
    const res = await geocode(txt);
    if (!res.length) throw new Error("Ingen träff på plats. Testa annan stavning eller skriv koordinater.");
    const first = res[0];
    // Put canonical display in the field
    placeInput.value = first.display;
    // Update cache so subsequent edits can match
    suggestionMap.set(first.display, { lat: first.lat, lon: first.lon, display: first.display });
    return { lat: first.lat, lon: first.lon, display: first.display, source: "geocode" };
  }

  async function update(){
    try {
      kVal.textContent = Number(kRange.value).toFixed(1);
      nVal.textContent = Number(nRange.value).toFixed(2);

      const ymd = dateInput.value;
      const stepMin = Math.max(5, Math.min(60, Number(stepInput.value) || 10));
      samplingShow.textContent = `${stepMin} min`;

      setStatus("Uppdaterar…");

      const place = await resolvePlaceToCoords();
      const { lat, lon } = place;

      const forecast = await fetchOpenMeteoForecast(lat, lon, ymd);
      const { tzName, offsetSec, xsSec, uvAll, uvClear, dailyMaxAll, dailyMaxClear } = forecast;

      // Build UTC timeline for local 07:00–19:00 at location:
      const [yy, mm, dd] = ymd.split("-").map(Number);
      const startUtcSec = Math.floor(Date.UTC(yy, mm-1, dd, START_H, 0, 0) / 1000) - offsetSec;
      const endUtcSec   = Math.floor(Date.UTC(yy, mm-1, dd, END_H,   0, 0) / 1000) - offsetSec;

      const timesH = [];
      const series = { clear: [], all: [], geo: [] };

      const Kuser = Number(kRange.value);
      const n = Number(nRange.value);
      const tzHours = offsetSec / 3600;

      for (let t = startUtcSec; t <= endUtcSec; t += stepMin * 60) {
        const localH = localHoursFromUtcSec(t, offsetSec);
        timesH.push(localH);

        const c = linearInterpAt(t, xsSec, uvClear);
        const a = linearInterpAt(t, xsSec, uvAll);

        series.clear.push(Math.max(0, c));
        series.all.push(Math.max(0, a));

        const elev = solarElevationDeg(localH, lat, lon, tzHours, yy, mm, dd);
        series.geo.push(Math.max(0, uvFromElevation(elev, Kuser, n)));
      }

      const clearPeak = (typeof dailyMaxClear === "number" && Number.isFinite(dailyMaxClear))
        ? dailyMaxClear
        : Math.max(...series.clear);

      const allPeak = (typeof dailyMaxAll === "number" && Number.isFinite(dailyMaxAll))
        ? dailyMaxAll
        : Math.max(...series.all);

      const geoPeakBase = Math.max(...series.geo);

      let scale = null;
      let Keffective = Kuser;

      if (autoK.checked && geoPeakBase > 0 && Number.isFinite(clearPeak) && clearPeak > 0) {
        scale = clearPeak / geoPeakBase;
        Keffective = Kuser * scale;

        series.geo = [];
        for (let i=0;i<timesH.length;i++){
          const localH = timesH[i];
          const elev = solarElevationDeg(localH, lat, lon, tzHours, yy, mm, dd);
          series.geo.push(Math.max(0, uvFromElevation(elev, Keffective, n)));
        }
      }

      // Time-of-max among enabled curves (approx from sampled curves)
      let bestIdx = 0, bestVal = -1;
      for (let i=0;i<timesH.length;i++){
        const candidates = [];
        if (showClear.checked) candidates.push(series.clear[i]);
        if (showAll.checked)   candidates.push(series.all[i]);
        if (showGeo.checked)   candidates.push(series.geo[i]);
        const v = Math.max(...candidates);
        if (v > bestVal) { bestVal = v; bestIdx = i; }
      }
      const tBestUtcSec = startUtcSec + bestIdx * stepMin * 60;

      // Info panel
      tzShow.textContent = tzName;
      latLon.textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;

      maxClear.textContent = Number(clearPeak).toFixed(1);
      maxAll.textContent   = Number(allPeak).toFixed(1);
      maxGeo.textContent   = Math.max(...series.geo).toFixed(1);

      kUserShow.textContent = Kuser.toFixed(2);
      kEff.textContent      = Keffective.toFixed(2);
      scaleShow.textContent = (scale === null) ? "—" : scale.toFixed(3);

      maxTime.textContent = fmtLocalHHMMFromUtcSec(tBestUtcSec, offsetSec);

      drawAll(timesH, series);
      setStatus("Uppdaterad.");
    } catch (e) {
      if (e?.name === "AbortError") return;
      setStatus(e.message || String(e), true);
    }
  }

  function requestGeo(){
    if (!navigator.geolocation){
      setStatus("Geolocation stöds inte i denna webbläsare.", true);
      return;
    }
    setStatus("Hämtar GPS…");
    navigator.geolocation.getCurrentPosition(
      async (pos) => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        // Reverse geocoding finns inte i Open-Meteo Geocoding API,
        // så vi fyller coords här.
        placeInput.value = `${lat.toFixed(4)} ${lon.toFixed(4)}`;
        setDatalist([]);
        await update();
      },
      (err) => setStatus(`Kunde inte hämta GPS: ${err.message}`, true),
      { enableHighAccuracy:true, timeout:12000, maximumAge:60000 }
    );
  }

  // Autocomplete: update datalist while typing
  placeInput.addEventListener("input", onPlaceInput);

  // Actions
  gpsBtn.addEventListener("click", requestGeo);
  updateBtn.addEventListener("click", update);

  // Re-render on settings changes (auto-update only if place is valid-ish)
  function softUpdate(){
    const t = placeInput.value.trim();
    // update if coords, or if they selected an existing suggestion, or if >= 2 chars (we can geocode)
    if (parseLatLon(t) || suggestionMap.has(t) || t.length >= 2) update();
  }
  [dateInput, showClear, showGeo, showAll, stepInput, kRange, nRange, autoK].forEach(x => x.addEventListener("input", softUpdate));
  placeInput.addEventListener("change", softUpdate);

  // Init
  dateInput.value = todayLocalYMD();
  kVal.textContent = Number(kRange.value).toFixed(1);
  nVal.textContent = Number(nRange.value).toFixed(2);
  samplingShow.textContent = `${Number(stepInput.value) || 10} min`;
})();
</script>
</body>
</html>