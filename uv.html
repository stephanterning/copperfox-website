<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Klar-himmel UV (GPS) 07–19</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121923; --text:#e7eef7; --muted:#a9b7c6;
      --border:rgba(255,255,255,.09); --accent:#56b6c2; --danger:#e06c75;
    }
    *{box-sizing:border-box}
    body{
      margin:0; padding:18px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 20% 0%, rgba(86,182,194,.18), transparent 60%), var(--bg);
      color:var(--text);
    }
    .wrap{max-width:980px;margin:0 auto;display:grid;gap:14px}
    header{display:flex;flex-wrap:wrap;gap:10px 14px;align-items:baseline}
    h1{font-size:18px;margin:0}
    .tag{font-size:12px;color:var(--muted);border:1px solid var(--border);padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.03)}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);border-radius:14px;padding:14px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;align-items:end}
    @media (max-width:700px){.row{grid-template-columns:1fr}}
    label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    input[type="date"], input[type="number"]{
      width:100%; padding:10px;
      border-radius:10px;border:1px solid var(--border);
      background:rgba(0,0,0,.25);color:var(--text);outline:none
    }
    input[type="range"]{width:100%}
    .btns{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
    button{
      cursor:pointer; border:1px solid var(--border);
      background:rgba(255,255,255,.04); color:var(--text);
      padding:10px 12px; border-radius:10px; font-weight:600;
    }
    button.primary{border-color:rgba(86,182,194,.55);background:rgba(86,182,194,.12)}
    button:hover{background:rgba(255,255,255,.07)}
    button.primary:hover{background:rgba(86,182,194,.18)}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .small{font-size:12px;color:var(--muted);line-height:1.35}
    .pill{
      display:flex;justify-content:space-between;gap:10px;align-items:center;
      padding:8px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,.03);
      font-size:12px;color:var(--muted)
    }
    canvas{
      width:100%; height:360px;
      background:rgba(0,0,0,.18);
      border:1px solid var(--border);
      border-radius:12px;
    }
    .status{font-size:12px;color:var(--muted)}
    .status.err{color:var(--danger)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Klar-himmel UV-index (GPS) 07:00–19:00</h1>
      <span class="tag">Endast solgeometri · ingen molnprognos</span>
      <span class="tag mono">single-file</span>
    </header>

    <section class="panel">
      <div class="row">
        <label>
          Datum (för din plats)
          <input id="dateInput" type="date" />
        </label>

        <label>
          Sampling (minuter)
          <input id="stepInput" type="number" min="5" max="60" step="5" value="10" />
        </label>
      </div>

      <div class="row" style="margin-top:10px;">
        <label>
          K (skalning)
          <input id="kRange" type="range" min="6" max="16" step="0.1" value="11.0" />
          <span class="mono" id="kVal">11.0</span>
        </label>

        <label>
          n (exponent)
          <input id="nRange" type="range" min="1.0" max="1.8" step="0.01" value="1.30" />
          <span class="mono" id="nVal">1.30</span>
        </label>
      </div>

      <div class="btns">
        <button class="primary" id="geoBtn">Hämta GPS-position</button>
        <button id="redrawBtn">Rita om</button>
      </div>

      <p class="small" style="margin:10px 0 0;">
        Modell: <span class="mono">UV = K · sin(elev)^n</span>, där <span class="mono">elev</span> är solens höjdvinkel.
        Det här är “maximal möjlig UV” om solen tittar fram (klar himmel).
      </p>
      <div id="status" class="status" style="margin-top:8px;">Redo. Tryck “Hämta GPS-position”.</div>
    </section>

    <section class="panel">
      <div class="pill"><span>Lat / Lon</span><span class="mono" id="latLon">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>UTC-offset (från din telefon)</span><span class="mono" id="tzShow">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>Max UV</span><span class="mono" id="maxUv">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>Tid för max</span><span class="mono" id="maxTime">—</span></div>
    </section>

    <section class="panel">
      <canvas id="chart" width="1200" height="500"></canvas>
    </section>
  </div>

<script>
(() => {
  // ---- UI ----
  const el = (id) => document.getElementById(id);
  const dateInput = el("dateInput");
  const stepInput = el("stepInput");
  const kRange = el("kRange");
  const nRange = el("nRange");
  const kVal = el("kVal");
  const nVal = el("nVal");
  const geoBtn = el("geoBtn");
  const redrawBtn = el("redrawBtn");

  const latLon = el("latLon");
  const tzShow = el("tzShow");
  const maxUv = el("maxUv");
  const maxTime = el("maxTime");
  const status = el("status");

  const canvas = el("chart");
  const ctx = canvas.getContext("2d");

  // ---- Model params ----
  const START_H = 7;
  const END_H = 19;

  let state = {
    lat: null,
    lon: null,
    tz: null // UTC offset in hours from device
  };

  function setStatus(msg, isErr=false){
    status.textContent = msg;
    status.classList.toggle("err", !!isErr);
  }

  function pad2(n){ return String(n).padStart(2, "0"); }
  function fmtTime(hFloat){
    const h = Math.floor(hFloat);
    const m = Math.round((hFloat - h) * 60);
    return `${pad2(h)}:${pad2(m)}`;
  }

  // today string in user's local timezone
  function todayLocalYMD(){
    const d = new Date();
    return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  }

  // Parse yyyy-mm-dd
  function parseYMD(s){
    const [y,m,d] = s.split("-").map(Number);
    return {y,m,d};
  }

  function dayOfYear(y,m,d){
    const dt = new Date(Date.UTC(y, m-1, d));
    const start = new Date(Date.UTC(y, 0, 1));
    return Math.floor((dt - start)/86400000) + 1;
  }

  // Solar elevation approximation (fractional year + equation of time)
  function solarElevationDeg(localClockHours, latDeg, lonDeg, tzHours, y, m, d){
    const doy = dayOfYear(y,m,d);

    const gamma = 2 * Math.PI / 365 * (doy - 1 + (localClockHours - 12) / 24);

    const decl =
      0.006918
      - 0.399912 * Math.cos(gamma)
      + 0.070257 * Math.sin(gamma)
      - 0.006758 * Math.cos(2 * gamma)
      + 0.000907 * Math.sin(2 * gamma)
      - 0.002697 * Math.cos(3 * gamma)
      + 0.00148  * Math.sin(3 * gamma);

    const eqtime =
      229.18 * (
        0.000075
        + 0.001868 * Math.cos(gamma)
        - 0.032077 * Math.sin(gamma)
        - 0.014615 * Math.cos(2 * gamma)
        - 0.040849 * Math.sin(2 * gamma)
      );

    const minutes = localClockHours * 60;
    const tst = minutes + eqtime + 4 * lonDeg - 60 * tzHours;
    const haDeg = (tst / 4) - 180;
    const ha = haDeg * Math.PI / 180;

    const lat = latDeg * Math.PI / 180;
    const elevRad = Math.asin(
      Math.sin(lat) * Math.sin(decl) +
      Math.cos(lat) * Math.cos(decl) * Math.cos(ha)
    );

    return elevRad * 180 / Math.PI;
  }

  function uvFromElevation(elevDeg, K, n){
    if (elevDeg <= 0) return 0;
    const s = Math.sin(elevDeg * Math.PI / 180);
    return K * Math.pow(Math.max(0, s), n);
  }

  function computeSeries(){
    if (!Number.isFinite(state.lat) || !Number.isFinite(state.lon) || !Number.isFinite(state.tz)) {
      throw new Error("Ingen GPS-position ännu.");
    }
    const {y,m,d} = parseYMD(dateInput.value);
    const step = Math.max(5, Math.min(60, Number(stepInput.value) || 10));
    const K = Number(kRange.value);
    const n = Number(nRange.value);

    const times = [];
    const values = [];

    for (let t = START_H*60; t <= END_H*60; t += step) {
      const h = t/60;
      const elev = solarElevationDeg(h, state.lat, state.lon, state.tz, y, m, d);
      const uv = uvFromElevation(elev, K, n);
      times.push(h);
      values.push(uv);
    }

    let maxV=-1, idx=0;
    for (let i=0;i<values.length;i++){
      if (values[i] > maxV) { maxV = values[i]; idx = i; }
    }
    return {times, values, maxV, maxT: times[idx], step};
  }

  function draw(series){
    const {times, values} = series;

    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    const pad = {l:56, r:18, t:18, b:44};
    const pw = w - pad.l - pad.r;
    const ph = h - pad.t - pad.b;

    const yMaxRaw = Math.max(1, ...values);
    const yMax = Math.ceil(yMaxRaw * 2) / 2; // round to 0.5

    const xMin = START_H, xMax = END_H;

    const xTo = (x) => pad.l + ((x - xMin) / (xMax - xMin)) * pw;
    const yTo = (y) => pad.t + (1 - (y / yMax)) * ph;

    // grid
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.fillStyle = "rgba(231,238,247,0.75)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

    const yStep = (yMax <= 4) ? 0.5 : (yMax <= 8 ? 1 : 2);
    for (let y=0; y<=yMax+1e-9; y+=yStep){
      const py = yTo(y);
      ctx.beginPath(); ctx.moveTo(pad.l, py); ctx.lineTo(w-pad.r, py); ctx.stroke();
      ctx.fillText(y.toFixed(yStep<1 ? 1 : 0), 10, py+4);
    }
    for (let x=START_H; x<=END_H; x++){
      const px = xTo(x);
      ctx.beginPath(); ctx.moveTo(px, pad.t); ctx.lineTo(px, h-pad.b); ctx.stroke();
      ctx.fillText(`${pad2(x)}:00`, px-18, h-16);
    }
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(pad.l, pad.t, pw, ph);
    ctx.restore();

    // line
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(86,182,194,0.95)";
    ctx.beginPath();
    for (let i=0;i<times.length;i++){
      const x = xTo(times[i]);
      const y = yTo(values[i]);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();

    // fill
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(86,182,194,0.35)";
    ctx.beginPath();
    for (let i=0;i<times.length;i++){
      const x = xTo(times[i]);
      const y = yTo(values[i]);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.lineTo(xTo(xMax), yTo(0));
    ctx.lineTo(xTo(xMin), yTo(0));
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function updateSummary(series){
    latLon.textContent = `${state.lat.toFixed(4)}, ${state.lon.toFixed(4)}`;
    tzShow.textContent = (state.tz>=0?"+":"") + state.tz;
    maxUv.textContent = series.maxV.toFixed(1);
    maxTime.textContent = fmtTime(series.maxT);
  }

  function redraw(){
    try {
      kVal.textContent = Number(kRange.value).toFixed(1);
      nVal.textContent = Number(nRange.value).toFixed(2);

      const series = computeSeries();
      draw(series);
      updateSummary(series);
      setStatus(`Ritad (${series.step} min sampling).`);
    } catch (e) {
      setStatus(e.message || String(e), true);
    }
  }

  function requestGeo(){
    if (!navigator.geolocation){
      setStatus("Geolocation stöds inte i denna webbläsare.", true);
      return;
    }
    setStatus("Hämtar GPS-position…");
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        state.lat = pos.coords.latitude;
        state.lon = pos.coords.longitude;
        // Use device timezone offset (hours). This is correct for the user's current position
        // as long as device timezone matches the physical location (usually true).
        state.tz = -new Date().getTimezoneOffset() / 60;

        if (!dateInput.value) dateInput.value = todayLocalYMD();
        redraw();
      },
      (err) => setStatus(`Kunde inte hämta position: ${err.message}`, true),
      { enableHighAccuracy:true, timeout:12000, maximumAge:60000 }
    );
  }

  // ---- wire events ----
  geoBtn.addEventListener("click", requestGeo);
  redrawBtn.addEventListener("click", redraw);
  [dateInput, stepInput, kRange, nRange].forEach(x => x.addEventListener("input", redraw));

  // init
  dateInput.value = todayLocalYMD();
  kVal.textContent = Number(kRange.value).toFixed(1);
  nVal.textContent = Number(nRange.value).toFixed(2);
})();
</script>
</body>
</html>