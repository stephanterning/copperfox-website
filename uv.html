<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>UV-index (Clear Sky) 07–19</title>
  <style>
    :root{
      --bg:#0b0f14; --text:#e7eef7; --muted:#a9b7c6;
      --border:rgba(255,255,255,.09); --accent:#56b6c2; --danger:#e06c75;
      --panelA:rgba(255,255,255,.04); --panelB:rgba(255,255,255,.02);

      /* UV band colors (subtle; dark UI) */
      --uv-low:   rgba(152,195,121,0.10); /* 0-2 */
      --uv-mod:   rgba(229,192,123,0.10); /* 3-5 */
      --uv-high:  rgba(224,108,117,0.10); /* 6-7 */
      --uv-vhigh: rgba(198,120,221,0.12); /* 8-10 */
      --uv-ext:   rgba(97,175,239,0.12);  /* 11+ */
    }
    *{box-sizing:border-box}
    body{
      margin:0; padding:18px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 20% 0%, rgba(86,182,194,.18), transparent 60%), var(--bg);
      color:var(--text);
    }
    .wrap{max-width:980px;margin:0 auto;display:grid;gap:14px}
    header{display:flex;flex-wrap:wrap;gap:10px 14px;align-items:baseline}
    h1{font-size:18px;margin:0}
    .tag{font-size:12px;color:var(--muted);border:1px solid var(--border);padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.03)}
    .panel{
      background:linear-gradient(180deg, var(--panelA), var(--panelB));
      border:1px solid var(--border);
      border-radius:14px;
      padding:14px
    }
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px;align-items:end}
    @media (max-width:700px){.row{grid-template-columns:1fr}}
    label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    input[type="date"], input[type="number"]{
      width:100%; padding:10px;
      border-radius:10px;border:1px solid var(--border);
      background:rgba(0,0,0,.25);color:var(--text);outline:none
    }
    .btns{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px}
    button{
      cursor:pointer; border:1px solid var(--border);
      background:rgba(255,255,255,.04); color:var(--text);
      padding:10px 12px; border-radius:10px; font-weight:600;
    }
    button.primary{border-color:rgba(86,182,194,.55);background:rgba(86,182,194,.12)}
    button:hover{background:rgba(255,255,255,.07)}
    button.primary:hover{background:rgba(86,182,194,.18)}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .small{font-size:12px;color:var(--muted);line-height:1.4}
    .pill{
      display:flex;justify-content:space-between;gap:10px;align-items:center;
      padding:8px 10px;border-radius:999px;border:1px solid var(--border);background:rgba(255,255,255,.03);
      font-size:12px;color:var(--muted)
    }
    canvas{
      width:100%; height:360px;
      background:rgba(0,0,0,.18);
      border:1px solid var(--border);
      border-radius:12px;
    }
    .status{font-size:12px;color:var(--muted)}
    .status.err{color:var(--danger)}

    details{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 12px;
      background:rgba(0,0,0,.16);
      margin-top:12px;
    }
    summary{
      cursor:pointer;
      color:var(--text);
      font-weight:700;
      list-style:none;
      display:flex;
      align-items:center;
      gap:10px;
    }
    summary::-webkit-details-marker { display:none; }
    .chev{
      width:10px;height:10px;display:inline-block;
      border-right:2px solid rgba(231,238,247,.7);
      border-bottom:2px solid rgba(231,238,247,.7);
      transform:rotate(-45deg);
      margin-top:2px;
    }
    details[open] .chev{ transform:rotate(45deg); margin-top:0; }
    .advGrid{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width:700px){.advGrid{grid-template-columns:1fr}}
    .legend{
      display:flex; flex-wrap:wrap; gap:8px; margin-top:10px
    }
    .lg{
      display:flex; align-items:center; gap:8px;
      border:1px solid var(--border); background:rgba(255,255,255,.03);
      padding:6px 10px; border-radius:999px; font-size:12px; color:var(--muted)
    }
    .sw{width:10px;height:10px;border-radius:3px; display:inline-block}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>UV-index (Clear Sky) 07:00–19:00</h1>
      <span class="tag">Open-Meteo · UV Index Clear Sky</span>
      <span class="tag">Ingen molnprognos</span>
    </header>

    <section class="panel">
      <div class="row">
        <label>
          Datum (lokal tid för platsen)
          <input id="dateInput" type="date" />
        </label>

        <div style="display:grid;gap:10px">
          <div class="btns" style="margin:0">
            <button class="primary" id="geoBtn">Hämta GPS-position</button>
            <button id="redrawBtn">Hämta & rita</button>
          </div>
          <div id="status" class="status">Redo. Tryck “Hämta GPS-position”.</div>
        </div>
      </div>

      <details>
        <summary><span class="chev"></span> Avancerade inställningar</summary>

        <div class="advGrid">
          <label>
            Sampling (minuter)
            <input id="stepInput" type="number" min="5" max="60" step="5" value="10" />
            <span class="small">Open-Meteo ger timvärden. Här interpolerar vi linjärt till t.ex. 10 min.</span>
          </label>

          <div class="small">
            <b>Hur det funkar</b><br/>
            Vi hämtar <span class="mono">hourly=uv_index_clear_sky</span> från Open-Meteo och sätter
            <span class="mono">timezone=auto</span> så tiderna kommer i lokal tid för koordinaten.  [oai_citation:1‡Open Meteo](https://open-meteo.com/en/docs)
            <br/><br/>
            Kurvan är alltså “klar himmel” från en väder-/strålningsmodell, inte din egen
            <span class="mono">sin(elev)</span>-approximation.
          </div>
        </div>

        <div class="legend">
          <div class="lg"><span class="sw" style="background:var(--uv-low)"></span>0–2 Låg</div>
          <div class="lg"><span class="sw" style="background:var(--uv-mod)"></span>3–5 Måttlig</div>
          <div class="lg"><span class="sw" style="background:var(--uv-high)"></span>6–7 Hög</div>
          <div class="lg"><span class="sw" style="background:var(--uv-vhigh)"></span>8–10 Mycket hög</div>
          <div class="lg"><span class="sw" style="background:var(--uv-ext)"></span>11+ Extrem</div>
        </div>
      </details>
    </section>

    <section class="panel">
      <div class="pill"><span>Lat / Lon</span><span class="mono" id="latLon">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>Timezone (API)</span><span class="mono" id="tzShow">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>Max UV (clear sky)</span><span class="mono" id="maxUv">—</span></div>
      <div class="pill" style="margin-top:10px;"><span>Tid för max</span><span class="mono" id="maxTime">—</span></div>
    </section>

    <section class="panel">
      <canvas id="chart" width="1200" height="500"></canvas>
    </section>
  </div>

<script>
(() => {
  const el = (id) => document.getElementById(id);

  const dateInput = el("dateInput");
  const stepInput = el("stepInput");
  const geoBtn = el("geoBtn");
  const redrawBtn = el("redrawBtn");

  const latLon = el("latLon");
  const tzShow = el("tzShow");
  const maxUv = el("maxUv");
  const maxTime = el("maxTime");
  const status = el("status");

  const canvas = el("chart");
  const ctx = canvas.getContext("2d");

  const START_H = 7;
  const END_H = 19;

  let state = { lat: null, lon: null };
  let inflight = null;

  function setStatus(msg, isErr=false){
    status.textContent = msg;
    status.classList.toggle("err", !!isErr);
  }
  function pad2(n){ return String(n).padStart(2,"0"); }
  function fmtTime(hFloat){
    const h = Math.floor(hFloat);
    const m = Math.round((hFloat - h) * 60);
    return `${pad2(h)}:${pad2(m)}`;
  }
  function todayLocalYMD(){
    const d = new Date();
    return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
  }

  // Parse "YYYY-MM-DDTHH:MM" (no timezone) as local time
  function parseLocalIso(isoNoZone){
    // Safari iOS: "YYYY-MM-DDTHH:MM" is usually OK as local, but we keep it explicit:
    const [datePart, timePart] = isoNoZone.split("T");
    const [y,m,d] = datePart.split("-").map(Number);
    const [hh,mm] = timePart.split(":").map(Number);
    return new Date(y, m-1, d, hh, mm || 0, 0, 0);
  }

  function clamp(x,a,b){ return Math.min(b, Math.max(a, x)); }

  function drawUvBands(pad, pw, ph, yMax){
    const styles = getComputedStyle(document.documentElement);
    const bands = [
      [0, 2,  styles.getPropertyValue("--uv-low").trim()],
      [2, 5,  styles.getPropertyValue("--uv-mod").trim()],
      [5, 7,  styles.getPropertyValue("--uv-high").trim()],
      [7, 10, styles.getPropertyValue("--uv-vhigh").trim()],
      [10, 99, styles.getPropertyValue("--uv-ext").trim()],
    ];
    const yTo = (y) => pad.t + (1 - (y / yMax)) * ph;

    for (const [a,b,color] of bands){
      const y0 = clamp(a, 0, yMax);
      const y1 = clamp(b, 0, yMax);
      if (y1 <= 0 || y0 >= yMax) continue;

      const top = yTo(y1);
      const bot = yTo(y0);
      ctx.fillStyle = color;
      ctx.fillRect(pad.l, top, pw, bot - top);
    }
  }

  function drawChart(timesH, values){
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    const pad = {l:56, r:18, t:18, b:44};
    const pw = w - pad.l - pad.r;
    const ph = h - pad.t - pad.b;

    const yMaxRaw = Math.max(1, ...values);
    const yMax = Math.ceil(yMaxRaw * 2) / 2;

    const xMin = START_H, xMax = END_H;
    const xTo = (x) => pad.l + ((x - xMin) / (xMax - xMin)) * pw;
    const yTo = (y) => pad.t + (1 - (y / yMax)) * ph;

    // bands
    drawUvBands(pad, pw, ph, yMax);

    // grid
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.fillStyle = "rgba(231,238,247,0.75)";
    ctx.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

    const yStep = (yMax <= 4) ? 0.5 : (yMax <= 8 ? 1 : 2);
    for (let y=0; y<=yMax+1e-9; y+=yStep){
      const py = yTo(y);
      ctx.beginPath(); ctx.moveTo(pad.l, py); ctx.lineTo(w-pad.r, py); ctx.stroke();
      ctx.fillText(y.toFixed(yStep<1 ? 1 : 0), 10, py+4);
    }
    for (let x=START_H; x<=END_H; x++){
      const px = xTo(x);
      ctx.beginPath(); ctx.moveTo(px, pad.t); ctx.lineTo(px, h-pad.b); ctx.stroke();
      ctx.fillText(`${pad2(x)}:00`, px-18, h-16);
    }
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(pad.l, pad.t, pw, ph);
    ctx.restore();

    // line
    ctx.save();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(86,182,194,0.95)";
    ctx.beginPath();
    for (let i=0;i<timesH.length;i++){
      const x = xTo(timesH[i]);
      const y = yTo(values[i]);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();

    // fill
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "rgba(86,182,194,0.35)";
    ctx.beginPath();
    for (let i=0;i<timesH.length;i++){
      const x = xTo(timesH[i]);
      const y = yTo(values[i]);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.lineTo(xTo(xMax), yTo(0));
    ctx.lineTo(xTo(xMin), yTo(0));
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function linearInterpAt(tMs, xsMs, ys){
    // xsMs must be sorted
    if (tMs <= xsMs[0]) return ys[0];
    const last = xsMs.length - 1;
    if (tMs >= xsMs[last]) return ys[last];

    // binary search
    let lo = 0, hi = last;
    while (hi - lo > 1) {
      const mid = (lo + hi) >> 1;
      if (xsMs[mid] <= tMs) lo = mid; else hi = mid;
    }
    const t0 = xsMs[lo], t1 = xsMs[hi];
    const y0 = ys[lo], y1 = ys[hi];
    const f = (tMs - t0) / (t1 - t0);
    return y0 + f * (y1 - y0);
  }

  async function fetchOpenMeteoUvClearSky(lat, lon, ymd){
    const url = new URL("https://api.open-meteo.com/v1/forecast");
    url.searchParams.set("latitude", String(lat));
    url.searchParams.set("longitude", String(lon));
    url.searchParams.set("hourly", "uv_index_clear_sky");
    url.searchParams.set("timezone", "auto");
    url.searchParams.set("start_date", ymd);
    url.searchParams.set("end_date", ymd);

    // abort previous request if any
    if (inflight) inflight.abort();
    inflight = new AbortController();

    const res = await fetch(url.toString(), { signal: inflight.signal });
    if (!res.ok) throw new Error(`Open-Meteo fel: HTTP ${res.status}`);
    const data = await res.json();

    const tzName = data.timezone || "—";
    const times = data?.hourly?.time;
    const uvs = data?.hourly?.uv_index_clear_sky;

    if (!Array.isArray(times) || !Array.isArray(uvs) || times.length !== uvs.length) {
      throw new Error("Ovväntat svarformat från Open-Meteo.");
    }

    // Convert to ms
    const xsMs = times.map(parseLocalIso).map(d => d.getTime());
    return { xsMs, uvs, tzName };
  }

  async function redraw(){
    try {
      if (!Number.isFinite(state.lat) || !Number.isFinite(state.lon)) {
        throw new Error("Ingen GPS-position ännu.");
      }
      const ymd = dateInput.value;
      const step = Math.max(5, Math.min(60, Number(stepInput.value) || 10));

      setStatus("Hämtar Open-Meteo (uv_index_clear_sky)…");

      const { xsMs, uvs, tzName } = await fetchOpenMeteoUvClearSky(state.lat, state.lon, ymd);

      // Build sampling timeline 07:00–19:00 local day (same local zone as the API timestamps)
      const [yy, mm, dd] = ymd.split("-").map(Number);
      const start = new Date(yy, mm-1, dd, START_H, 0, 0, 0).getTime();
      const end   = new Date(yy, mm-1, dd, END_H,   0, 0, 0).getTime();

      const timesH = [];
      const values = [];

      for (let t = start; t <= end; t += step * 60000) {
        const d = new Date(t);
        const h = d.getHours() + d.getMinutes()/60;
        const uv = linearInterpAt(t, xsMs, uvs);
        timesH.push(h);
        values.push(Math.max(0, uv));
      }

      // max
      let maxV = -1, maxIdx = 0;
      for (let i=0;i<values.length;i++){
        if (values[i] > maxV) { maxV = values[i]; maxIdx = i; }
      }

      // UI
      latLon.textContent = `${state.lat.toFixed(4)}, ${state.lon.toFixed(4)}`;
      tzShow.textContent = tzName;
      maxUv.textContent = maxV.toFixed(1);
      maxTime.textContent = fmtTime(timesH[maxIdx]);

      drawChart(timesH, values);

      setStatus(`Ritad (${step} min).`);
    } catch (e) {
      if (e?.name === "AbortError") return; // user retriggered quickly
      setStatus(e.message || String(e), true);
    }
  }

  function requestGeo(){
    if (!navigator.geolocation){
      setStatus("Geolocation stöds inte i denna webbläsare.", true);
      return;
    }
    setStatus("Hämtar GPS-position…");
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        state.lat = pos.coords.latitude;
        state.lon = pos.coords.longitude;
        redraw();
      },
      (err) => setStatus(`Kunde inte hämta position: ${err.message}`, true),
      { enableHighAccuracy:true, timeout:12000, maximumAge:60000 }
    );
  }

  geoBtn.addEventListener("click", requestGeo);
  redrawBtn.addEventListener("click", redraw);
  [dateInput, stepInput].forEach(x => x.addEventListener("input", redraw));

  dateInput.value = todayLocalYMD();
})();
</script>
</body>
</html>